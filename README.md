### 写在前面的话

> 从2019年起准备系统地对使用R软件进行基础编程、数据分析和统计建模的内容进行总结和整理，并且对R语言的一些高级特性进行回顾（如闭包、泛函等），有时间会在github上陆续更新代码。
> 由于进度问题，R的内容不会像python那部分一样进行详细的注释，相关内容可通过阅读推荐读物进行学习。**推荐的读物会在末尾列出**

***

## 20190101―第一节：R的数据结构与帮助获取方法

1. 函数入门：重点掌握变量的作用域
    + 局部变量: **下周会在CSDN上更新一篇讲解R语言变量作用域的帖子**
    + 超赋值运算符: <<-
    + [R语言的闭包](https://blog.csdn.net/hdyshr/article/details/82744681)

2. R语言的数据结构
    + 向量：必须由相同类型数据组成
    + 字符串：后续学习会单独讲解字符串的细节
    + 矩阵
    + 列表：可以储存不同类型的数据
    + 数据框

3. R的泛型编程浅谈
    + summary()、plot()均为泛型函数，即一个函数族，根据不同的输入，可以从函数族中抽出适合的函数运行

3. R的帮助获取方法
    + help()
    + ?
    + example()
    + 模糊的功能查询：help.search()
    + ??

***

## 20190105――第二节：R的数据结构之向量

1. R向量与C语言（或其他ALGOL家族高级语言）中向量的区别
    + 向量名实际上是一个指针，向量创建后不可修改长度，若要修改只能重新复制
    + 遍历列表操作
    + ?seq()：学习seq()的用法
    + 向量加法的循环补齐规则

2.  常见的向量运算和索引
    + 二目运算符也是函数
    + R向量用“*”乘，获得新向量，而不是向量内积或外积
    + 多用()避免优先级错误
    + 用seq()生成等差数列（向量）
    + 用rep()生成循环数列（向量）
    + 用any(条件)和all(条件)对向量中的元素进行判断

3. 用R处理游程问题
    + 编程中如何减少内存消耗：避免头指针反复摆动
    + 累积和函数cumsum()

4. R中的缺失值NA和空值NULL
    + NA为缺失值：NA无法参与运算
    + NULL可以用来创建空指针：z <- NULL

5. R的筛选机制（filtering）
    + 用[条件]进行筛选
    + 用subset(向量名, 条件)进行筛选：可以避免NA的问题
    + 用which(条件)进行筛选

6. ifelse()函数的用法
    + 这个方法速度较快，因为进行的是纯向量化操作

> 补充：其他涉及的函数
> lapply(); diff(); sign(); identical(); 
> mode(); typeof()

***

## 20190106――第三节：R的矩阵和数组

1. 矩阵（二维）相关操作
     + 矩阵的基本操作
     + 用pixmap包处理灰度像素图
     + 对矩阵的行或列应用函数：apply()的用法
     + 矩阵拓展的方法：cbind()和rbind()的用法
     + 向量和矩阵的差异

2. 数组（多维）相关操作
     + 注意与python的numpy数组进行区分

## 20190201――第四节：前三节内容的复习

1. R的交互模式和批处理模式辨析

2. 在一个R脚本中调用外部R脚本代码可使用source("z.R") 

3. R中在pdf文件中绘图（并使用dev.off()关闭）

4. R的批处理命令：R CMD BATCH z.R

5. 超赋值运算符：<<- 用于在函数中给全局变量赋值

6. mode()和typeof()的区别：typeof() is more detailed

7. 矩阵乘法运算符：%*%

8. 显示S3对象的结构：str(S3对象) （short for structure）；str()同样适用于S4对象

9. class()的含义，并且与mode()和typeof()比较：class()用于判断对象的类型

10. attributes(对象)：列出一个对象的所有组件

11. 1:length(x)和seq(x)（or seq_along(x)）的比较

12. 创建向量时c()、rep()和seq()三种方法的比较

13. any()和all()的用法：用于对一个向量中的元素进行整体判断

14. 累积运算符的用法：cumsum()、cummax()、cummin()等，也是返回一个向量

15. sapply()函数的用法（simplify apply）:将函数应用在列表上，返回的是**向量**

16. NA和NULL的区别：NA是缺失值，需要特殊处理；NULL是空值，任何计算都会跳过NULL进行

17. 向量进行元素筛选时，直接在[]中写选择条件，和使用subset()函数的区别：subset()可以自动移除NA，而[]方式不能，将返回NA

18. which()：返回符合条件的向量元素的索引

19. args()：用于查看函数的参数

20. 判断元素相等使用“==”;判断向量是否相等则使用identical(x, y)：使用identical需要注意x和y的数据类型（typeof()判断）也应该相等

21. apply()函数用法的复习：apply()中调用的函数同样可以包含形参，在函数命后写传入的实参即可

22. which.max()和which.min()的用法

23. which()的进阶用法：当which()查找矩阵元素时，用参数arr.ind=T/F控制返回矩阵坐标还是拉伸后的向量坐标

24. 在矩阵的[]中使用drop = FALSE，防止对矩阵意外降维

***

## 20190202――R的列表和数据框

1. 要删除列表元素，可将该元素赋值NULL

2. 使用unlist()获取list内容：将list转化为一个向量

3. 两种方法去掉向量中的元素名：

    + names(向量) <- NULL
    + 新向量 <- unname(原向量)

4. lapply和sapply的比较：lapply()会返回一个原来的list结构，但是sapply()会拆解list为普通向量后返回

5. order()函数：返回排序后向量在原向量中的索引，向量名[order(向量名)]和sort()功能相同

6. 递归型列表：可用c(..., recursive = TRUE)压平

7. 创建数据框时，用stringAsFactors = FALSE进行控制

8. complete.cases(数据框)：判断各个条目中是否有NA，返回没有NA的行索引

9. 字符串的grep()函数：搜索一个字符串中有无给定的序列存在

10. 复习assign()的功能：通过pos= 可以在全局环境中生成顶级变量

11. merge()函数的用法：merge(a, b, by.x = , by.y = )

***

## 20190203――因子和表

1. 用factor构造因子变量

2. tapply()函数的功能：tapply(数值型变量，因子变量，函数)――可以按照因子分组，之后对另一数值型变量应用函数进行计算，之后返回向量

3. split()函数的功能：按照因子水平将数据框拆成多个表，而后一起构成一个列表

4. by()函数的功能：与tapply类似，区别是函数可应用在整个数据框上，比如用两列做一个线性回归

5. 用table()函数将数据转换为以factor为元素的table对象，用addmargin()函数可对margin value进行计算

6. subtable()函数可用于提取子表

7. 对对象应用unclass()函数解封，转换为普通的向量数据――在面向对象部分继续学习

8. 用array(data，dim，dimnames)生成一个多维数组

9. aggregate()函数：用于对分组后的每个变量应用函数进行计算

10. cut()函数：用于对数值型变量按照距离划分，生成factor

**注：可复习Wickham的reshape包的用法：melt()和cast()函数** 

***

## 20190204――R语言编程结构

1. 三种循环语句：for、while、repeat

2. 循环中break和next的区别

3. if-else条件控制语句

4. &&和||为标量（向量第一位）的逻辑运算符；&和|为向量的逻辑运算符

5. 函数也是个对象，第一个组件是形参列表，用formals()查看，第二个组件是函数体，用body()查看

6. 可以用**body(函数名) <- quote(函数体)**的方式对函数的主体进行修改

7. ls.str()可查看各个环境中对象的结构

8. R的闭包：函数中定义并且返回的函数，可以将函数的局部作用域中的变量带至上一级作用域

    + 闭包包含一个可创建局部变量的函数，并创建另一个函数可访问该变量

    + 闭包函数被实例化后，不同的闭包实体中的名称相同的变量都是独立开的

9. ls(envir = parent.frame(n = 1)): 向上一个框架（环境），显示局部变量

10. 函数式编程哲学：函数可以调用上层环境中的变量，但是不能对非函数的局部变量进行修改（尽量别）

11. ".GlobalEnv"可作为顶级环境直接调用；get(变量名，envir = )可以调用各个环境中的变量

12. assign()函数通过envir = ，可以实现对上层变量的赋值，类似<<-的功能，但是更加灵活

13. R中的递归：
    
    + R的快速排序算法实现

14. R中的置换函数：任何<-左边不是变量名而是函数的赋值情况都是置换函数

15. 创建自己的二元运算符："%?%" <- function(...) {函数体}

***

## 20190204：R中的数学运算初步

1. 求导和积分运算：

    + 求导：D(espression(exp(x^2)), "x")
    + 积分：integrate(function(x) x^2, 0, 1)

2. 统计分布函数：
    
    + d：pmf/pdf
    + p：累积分布函数
    + q：对应分布的中位数
    + r：对应生成相应分布的随机数

3. sort()、order()、rank()

4. 向量运算(*如果需要应用矩阵运算，后续请继续学习*)：

    + 数乘：n* A
    + 内积：crosspod(A, B)  **这里有问题，crosspod()其实是计算了内积，而不是叉积**
    + 外积：%*%
    + 解线性方程组：solve(A, b)

5. 集合运算：

    + 并集：union(a, b)
    + 交集：intersect(a, b)
    + 差集：setdiff(a, b)
    + 检验集合是否相等：setequal(a, b)
    + 判断是否为集合中元素：c %in% a
    + choose(numA, numB)：从numA个元素中选择numB个元素的组合数
    + combn(集合，n)：从集合中选n个元素的子集

6. 更多的随机数生成函数：rnorm(), rbinom(), rexp(), runif(), rgamma(), rpois()

7. 当指定set.seed()中种子的数字后，每次生成的随机数列相同：set.seed(889)

***

## 20190205――R的面向对象编程

1. R的S3对象：列表、类名属性、调度（dispatch）

2. 多态（polymorphic）：针对不同的类调用不同的方法

3. 用unclass()方法去掉一个对象的类属性，之后调用泛型函数就会产生问题

4. methods(泛型方法)：可以输出所有关联的方法

5. 通过**方法.类名 <- 函数体**的方式定义泛型方法

6. 通过**class(S3类) <- c(派生类, 父类)**的方式进行继承（inheritance）

7. print(S3类)后，系统就会调用UseMethod()方法，之后寻找该类的print方法，比如：class(z) <- c(if(is.matrix(y)) "mlm", "lm") 就是根据z的类型，判断某个数据属于哪个类

8. 怎么将自己写的S3类实例化？S3类在创建列表时就自动实例化

9. 用UseMethod("方法名")声明一个S3类的泛型方法，如print()，而后UseMethod()方法在环境中根据类名查找泛型方法

10. S4类通过setClass()进行定义，之后通过new()进行实例化，通过**setMethod()**创建泛型函数：slot(对象, "属性名")可查询某个S4对象的某个属性

11. 通过**save(对象，"数据名")  => load("数据名")**的方式可以先将数据保存在硬盘上，而后加载使用，防止因rm()在内存中被删除而无法后续使用
           
#### 参考读物(精华型图书)
> 下列图书并不很适合编程零基础的人士学习
1. 《R语言编程艺术》，Norman Matloff，机械工业出版社，2013.6。
2. 《数据科学：R语言实现》，Hadley Wickham & Garret Grolemund, 东南大学出版社。
3. 《高级R语言编程指南》，Hadley Wickham, 机械工业出版社。